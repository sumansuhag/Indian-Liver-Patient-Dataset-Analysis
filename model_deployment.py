# -*- coding: utf-8 -*-
"""Model_Deployment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y_MNOsDzYLotRwtA4KLh8CjtmK4lEJqT
"""

#Make necessary imports
import warnings
warnings.filterwarnings("ignore")

import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
import seaborn as sns
sns.set()

df = pd.read_csv("indian_liver_patient.csv")
df.head()

#find null Values in the data set

df.isnull().sum()

from sklearn.impute import SimpleImputer
imp_mode = SimpleImputer(missing_values=np.nan, strategy='mean')

df["Albumin_and_Globulin_Ratio"]=df["Albumin_and_Globulin_Ratio"].fillna(df["Albumin_and_Globulin_Ratio"].median())

df.isnull().sum()

from sklearn import preprocessing

df_enco=df.apply(preprocessing.LabelEncoder().fit_transform)
df_enco

# Finding Unique values in the columns

for i in df_enco.columns:
    print("*************************************************",i,"************************************************************")
    print()
    print(set(df_enco[i].tolist()))
    print()

# Lets make some final changes to the data

# Seperate independent and dependent variables and drop the ID column
x=df_enco.drop(["Dataset"],axis=1)
y=df_enco["Dataset"]

# Lets detect the label balance
from imblearn.over_sampling import RandomOverSampler
from imblearn.under_sampling import RandomUnderSampler
from collections import Counter

print(Counter(y))

# Lets balance the labels

ros = RandomOverSampler()

X_ros, y_ros = ros.fit_resample(x, y)
print(Counter(y_ros))

#Initialize a MinMaxScaler and scale the features to between -1 and 1 to normalize them.
#The MinMaxScaler transforms features by scaling them to a given range.
#The fit_transform() method fits to the data and then transforms it. We donâ€™t need to scale the labels.
#Scale the features to between -1 and 1

# Scaling is important in the algorithms such as support vector machines (SVM) and k-nearest neighbors (KNN) where distance
# between the data points is important.

scaler=MinMaxScaler((-1,1))
x=scaler.fit_transform(X_ros)
y=y_ros

#Now,split the dataset into training and testing sets keeping 20% of the data for testing.
#Split the dataset
from sklearn.model_selection import train_test_split

x_train,x_test,y_train,y_test=train_test_split(x, y, test_size=0.2, random_state=7)

from sklearn.ensemble import RandomForestClassifier
model = RandomForestClassifier(max_depth=4, random_state = 10)
model.fit(x_train, y_train)

from sklearn.metrics import accuracy_score
pred_cv = model.predict(x_test)
accuracy_score(y_test,pred_cv)

# saving the model
import pickle
pickle_out = open("classifier.pkl", mode = "wb")
pickle.dump(model, pickle_out)
pickle_out.close()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# 
# import pickle
# import streamlit as st
# 
# # loading the trained model
# pickle_in = open('classifier.pkl', 'rb')
# classifier = pickle.load(pickle_in)
# 
# @st.cache()
# 
# # defining the function which will make the prediction using the data which the user inputs
# def prediction(Age, Gender, Total_Bilirubin, Direct_Bilirubin, Alkaline_Phosphotase, Alamine_Aminotransferase, Aspartate_Aminotransferase, Total_Protiens, Albumin, Albumin_and_Globulin_Ratio):
# 
#     # Pre-processing user input
#     if Gender == "Female":
#         Gender = 0
#     else:
#         Gender = 1
# 
# 
# 
#     # Making predictions
#     prediction = classifier.predict([[Age, Gender, Total_Bilirubin, Direct_Bilirubin, Alkaline_Phosphotase, Alamine_Aminotransferase, Aspartate_Aminotransferase, Total_Protiens, Albumin, Albumin_and_Globulin_Ratio]])
# 
# 
#     if prediction == 0:
#         pred = 'Liver Disease not detected'
#     else:
#         pred = 'Liver Disease found'
#     return pred
# 
# 
# # this is the main function in which we define our webpage
# def main():
#     # front end elements of the web page
#     html_temp = """
#     <div style ="background-color:cyan;padding:13px">
#     <h1 style ="color:black;text-align:center;">Liver Disease Prediction</h1>
#     </div>
#     """
# 
#     # display the front end aspect
#     st.markdown(html_temp, unsafe_allow_html = True)
# 
#     # following lines create boxes in which user can enter data required to make prediction
# 
#     Gender = st.selectbox('Gender',("Female","Male"))
#     Age = st.number_input( "Age" )
#     Total_Bilirubin = st.number_input( "Total_Bilirubin" )
#     Direct_Bilirubin = st.number_input( "Direct_Bilirubin" )
#     Alkaline_Phosphotase = st.number_input( "Alkaline_Phosphotase" )
#     Alamine_Aminotransferase = st.number_input( "Alamine_Aminotransferase" )
#     Aspartate_Aminotransferase = st.number_input( "Aspartate_Aminotransferase" )
#     Total_Protiens = st.number_input( "Total_Protiens" )
#     Albumin = st.number_input( "Albumin" )
#     Albumin_and_Globulin_Ratio = st.number_input( "Albumin_and_Globulin_Ratio" )
# 
#     result =""
# 
#     # when 'Predict' is clicked, make the prediction and store it
#     if st.button("Predict"):
#         result = prediction(Age, Gender, Total_Bilirubin, Direct_Bilirubin, Alkaline_Phosphotase, Alamine_Aminotransferase, Aspartate_Aminotransferase, Total_Protiens, Albumin, Albumin_and_Globulin_Ratio)
#         st.success('Report Results: {}'.format(result))
# 
# 
# if __name__=='__main__':
#     main()

# Create a scatter plot
fig = px.scatter(df, x='Total_Bilirubin', y='Alkaline_Phosphotase', color='Dataset',
                 title='Scatter Plot of Total Bilirubin vs Alkaline Phosphotase')

# Show the plot
fig.show()

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

df = pd.read_csv("indian_liver_patient.csv")

# Count occurrences of each gender
gender_counts = df['Gender'].value_counts()

# Calculate cumulative percentage
gender_counts = gender_counts.sort_values(ascending=False)
cumulative_percentage = np.cumsum(gender_counts) / gender_counts.sum() * 100

# Create the Pareto chart
fig, ax1 = plt.subplots()

# Bar chart for frequencies
ax1.bar(gender_counts.index, gender_counts.values, color='blue', alpha=0.7)
ax1.set_xlabel('Gender')
ax1.set_ylabel('Count', color='blue')
ax1.tick_params(axis='y', labelcolor='blue')

# Create a second y-axis for cumulative percentage
ax2 = ax1.twinx()
ax2.plot(gender_counts.index, cumulative_percentage, color='red', marker='o', label='Cumulative Percentage')
ax2.set_ylabel('Cumulative Percentage (%)', color='red')
ax2.tick_params(axis='y', labelcolor='red')

# Title and grid
plt.title('Pareto Chart of Gender Distribution')
ax1.grid(axis='y')

# Show the plot
plt.show()

# Print the column names
print(df.columns)

import pandas as pd
import matplotlib.pyplot as plt

# Load the dataset
df = pd.read_csv("indian_liver_patient.csv")

# Print the column names to confirm the structure
print(df.columns)

# Creating a frequency table for the 'Dataset' column
frequency_table = df['Dataset'].value_counts()
print(frequency_table)

# Visualizing the frequency table as a pie chart
labels = frequency_table.index
sizes = frequency_table.values

# Bar chart
plt.figure(figsize=(8, 6))
plt.bar(labels, sizes, color='skyblue')
plt.xlabel('Liver Disease Status')
plt.ylabel('Frequency')
plt.title('Frequency of Liver Disease')
plt.xticks(rotation=45)
plt.show()